---
title: 在团队环境的 EF6 code First 迁移
author: divega
ms.date: 2016-10-23
ms.assetid: 4c2d9a95-de6f-4e97-9738-c1f8043eff69
ms.openlocfilehash: 42f52e63fd6cfc1f02d6a721594f4a161eea9a7b
ms.sourcegitcommit: dadee5905ada9ecdbae28363a682950383ce3e10
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/27/2018
ms.locfileid: "42997294"
---
# <a name="code-first-migrations-in-team-environments"></a><span data-ttu-id="2fbc8-102">在团队环境中的 code First 迁移</span><span class="sxs-lookup"><span data-stu-id="2fbc8-102">Code First Migrations in Team Environments</span></span>
> [!NOTE]
> <span data-ttu-id="2fbc8-103">本文假定你知道如何在基本方案中使用 Code First 迁移。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-103">This article assumes you know how to use Code First Migrations in basic scenarios.</span></span> <span data-ttu-id="2fbc8-104">如果不这样做，则你将需要读取[Code First 迁移](~/ef6/modeling/code-first/migrations/index.md)然后再继续。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-104">If you don’t, then you’ll need to read [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md) before continuing.</span></span>

## <a name="grab-a-coffee-you-need-to-read-this-whole-article"></a><span data-ttu-id="2fbc8-105">不要着急，您需要阅读此整篇文章</span><span class="sxs-lookup"><span data-stu-id="2fbc8-105">Grab a coffee, you need to read this whole article</span></span>

<span data-ttu-id="2fbc8-106">主要是关于合并两个开发人员已在其本地代码库中生成迁移时迁移是在团队环境中的问题。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-106">The issues in team environments are mostly around merging migrations when two developers have generated migrations in their local code base.</span></span> <span data-ttu-id="2fbc8-107">非常简单的步骤来解决这些时，它们需要你已迁移的工作原理的深入了解。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-107">While the steps to solve these are pretty simple, they require you to have a solid understanding of how migrations works.</span></span> <span data-ttu-id="2fbc8-108">请不要只是往前跳到最后 – 花时间阅读整篇文章中，以确保成功。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-108">Please don’t just skip ahead to the end – take the time to read the whole article to ensure you are successful.</span></span>

## <a name="some-general-guidelines"></a><span data-ttu-id="2fbc8-109">一些通用准则</span><span class="sxs-lookup"><span data-stu-id="2fbc8-109">Some general guidelines</span></span>

<span data-ttu-id="2fbc8-110">在我们深入了解到如何管理由多个开发人员生成的合并迁移之前，以下是一些通用准则，以获得成功。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-110">Before we dig into how to manage merging migrations generated by multiple developers, here are some general guidelines to set you up for success.</span></span>

### <a name="each-team-member-should-have-a-local-development-database"></a><span data-ttu-id="2fbc8-111">每个团队成员应具有一个本地开发数据库</span><span class="sxs-lookup"><span data-stu-id="2fbc8-111">Each team member should have a local development database</span></span>

<span data-ttu-id="2fbc8-112">迁移使用 **\_ \_MigrationsHistory**用于存储已应用哪些迁移到数据库表。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-112">Migrations uses the **\_\_MigrationsHistory** table to store what migrations have been applied to the database.</span></span> <span data-ttu-id="2fbc8-113">如果有多个开发人员尝试以相同的数据库为目标时生成不同的迁移 (并因此共享 **\_ \_MigrationsHistory**表) 迁移会感到很困惑。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-113">If you have multiple developers generating different migrations while trying to target the same database (and thus share a **\_\_MigrationsHistory** table) migrations is going to get very confused.</span></span>

<span data-ttu-id="2fbc8-114">当然，如果你的团队成员不会生成迁移，是让它们共享一个中央开发数据库没问题。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-114">Of course, if you have team members that aren’t generating migrations, there is no problem having them share a central development database.</span></span>

### <a name="avoid-automatic-migrations"></a><span data-ttu-id="2fbc8-115">避免自动迁移</span><span class="sxs-lookup"><span data-stu-id="2fbc8-115">Avoid automatic migrations</span></span>

<span data-ttu-id="2fbc8-116">底线是自动迁移最初看起来在团队环境中，很好，但实际上它们只是不起作用。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-116">The bottom line is that automatic migrations initially look good in team environments, but in reality they just don’t work.</span></span> <span data-ttu-id="2fbc8-117">如果你想要知道原因，往下读 – 如果没有，则可以跳过到下一节。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-117">If you want to know why, keep reading – if not, then you can skip to the next section.</span></span>

<span data-ttu-id="2fbc8-118">自动迁移，你可以在数据库架构已更新以匹配当前模型而无需生成代码文件 （基于代码的迁移）。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-118">Automatic migrations allows you to have your database schema updated to match the current model without the need to generate code files (code-based migrations).</span></span> <span data-ttu-id="2fbc8-119">如果只使用它们，并且永远不生成任何基于代码的迁移，自动迁移将在团队环境中很好地进行工作。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-119">Automatic migrations would work very well in a team environment if you only ever used them and never generated any code-based migrations.</span></span> <span data-ttu-id="2fbc8-120">问题是，自动迁移限制，并且不处理多个操作 – 属性/列重命名、 将数据移到另一个表，等等。若要处理这些方案，最终会生成基于代码的迁移 （和编辑基架的代码） 的混合之间由自动迁移的更改。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-120">The problem is that automatic migrations are limited and don’t handle a number of operations – property/column renames, moving data to another table, etc. To handle these scenarios you end up generating code-based migrations (and editing the scaffolded code) that are mixed in between changes that are handled by automatic migrations.</span></span> <span data-ttu-id="2fbc8-121">这使得它附近上是不可能将更改合并两个开发人员签入迁移时。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-121">This makes it near on impossible to merge changes when two developers check in migrations.</span></span>

## <a name="screencasts"></a><span data-ttu-id="2fbc8-122">屏幕广播</span><span class="sxs-lookup"><span data-stu-id="2fbc8-122">Screencasts</span></span>

<span data-ttu-id="2fbc8-123">如果您而是将观看截屏视频比阅读这篇文章时，以下两个视频涵盖的内容与这篇文章相同。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-123">If you'd rather watch a screencast than read this article, the following two videos cover the same content as this article.</span></span>

### <a name="video-one-migrations---under-the-hood"></a><span data-ttu-id="2fbc8-124">视频的一个:"迁移-实质上"</span><span class="sxs-lookup"><span data-stu-id="2fbc8-124">Video One: "Migrations - Under the Hood"</span></span>

<span data-ttu-id="2fbc8-125">[此截屏视频](http://channel9.msdn.com/blogs/ef/migrations-under-the-hood)介绍了如何迁移跟踪和使用有关模型的信息来检测模型更改。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-125">[This screencast](http://channel9.msdn.com/blogs/ef/migrations-under-the-hood) covers how migrations tracks and uses information about the model to detect model changes.</span></span>

### <a name="video-two-migrations---team-environments"></a><span data-ttu-id="2fbc8-126">视频 2:"迁移的团队环境"</span><span class="sxs-lookup"><span data-stu-id="2fbc8-126">Video Two: "Migrations - Team Environments"</span></span>

<span data-ttu-id="2fbc8-127">在上一视频中，从概念上构建[此截屏视频](http://channel9.msdn.com/blogs/ef/migrations-team-environments)介绍了在团队环境以及如何解决这些问题出现的问题。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-127">Building on the concepts from the previous video, [this screencast](http://channel9.msdn.com/blogs/ef/migrations-team-environments) covers the issues that arise in a team environment and how to solve them.</span></span>

## <a name="understanding-how-migrations-works"></a><span data-ttu-id="2fbc8-128">了解如何迁移的工作原理</span><span class="sxs-lookup"><span data-stu-id="2fbc8-128">Understanding how migrations works</span></span>

<span data-ttu-id="2fbc8-129">已成功在团队环境中使用迁移的关键是一个基本了解如何迁移跟踪和使用有关模型的信息来检测模型更改。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-129">The key to successfully using migrations in a team environment is a basic understanding how migrations tracks and uses information about the model to detect model changes.</span></span>

### <a name="the-first-migration"></a><span data-ttu-id="2fbc8-130">第一次迁移</span><span class="sxs-lookup"><span data-stu-id="2fbc8-130">The first migration</span></span>

<span data-ttu-id="2fbc8-131">当将第一次迁移添加到你的项目时，运行以下**添加迁移第一个**包管理器控制台中。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-131">When you add the first migration to your project, you run something like **Add-Migration First** in Package Manager Console.</span></span> <span data-ttu-id="2fbc8-132">此命令执行的高级别步骤将如下图所示。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-132">The high level steps that this command performs are pictured below.</span></span>

![FirstMigration](~/ef6/media/firstmigration.png)

<span data-ttu-id="2fbc8-134">当前模型会计算从你的代码 (1)。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-134">The current model is calculated from your code (1).</span></span> <span data-ttu-id="2fbc8-135">然后，所需的数据库对象的计算方法是模型的区别 (2) – 由于这是第一次迁移模型不同只需使用用于比较的空模型。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-135">The required database objects are then calculated by the model differ (2) – since this is the first migration the model differ just uses an empty model for the comparison.</span></span> <span data-ttu-id="2fbc8-136">所需的更改将传递给代码生成器以生成随后将添加到 Visual Studio 解决方案 (4) 的需要的迁移代码 (3)。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-136">The required changes are passed to the code generator to build the required migration code (3) which is then added to your Visual Studio solution (4).</span></span>

<span data-ttu-id="2fbc8-137">除了存储在主代码文件中的实际迁移代码，迁移还会生成一些额外的代码隐藏文件。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-137">In addition to the actual migration code that is stored in the main code file, migrations also generates some additional code-behind files.</span></span> <span data-ttu-id="2fbc8-138">这些文件是由迁移的元数据，而不应编辑的内容。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-138">These files are metadata that is used by migrations and are not something you should edit.</span></span> <span data-ttu-id="2fbc8-139">这些文件之一是模型的在迁移的生成的时间包含快照的资源文件 (.resx)。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-139">One of these files is a resource file (.resx) that contains a snapshot of the model at the time the migration was generated.</span></span> <span data-ttu-id="2fbc8-140">您将看到如何使用此方法在下一步。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-140">You’ll see how this is used in the next step.</span></span>

<span data-ttu-id="2fbc8-141">此时可能会运行**Update-database**应用到数据库，所做的更改，然后转有关实现你的应用程序的其他区域。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-141">At this point you would probably run **Update-Database** to apply your changes to the database, and then go about implementing other areas of your application.</span></span>

### <a name="subsequent-migrations"></a><span data-ttu-id="2fbc8-142">以后的迁移</span><span class="sxs-lookup"><span data-stu-id="2fbc8-142">Subsequent migrations</span></span>

<span data-ttu-id="2fbc8-143">回到，对模型进行一些更改 – 在本例中我们将添加更高版本**Url**属性设置为**博客**。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-143">Later you come back and make some changes to your model – in our example we’ll add a **Url** property to **Blog**.</span></span> <span data-ttu-id="2fbc8-144">然后将如发出命令**Add-migration AddUrl**搭建基架，迁移，以将相应的数据库应用更改。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-144">You would then issue a command such as **Add-Migration AddUrl** to scaffold a migration to apply the corresponding database changes.</span></span> <span data-ttu-id="2fbc8-145">此命令执行的高级别步骤将如下图所示。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-145">The high level steps that this command performs are pictured below.</span></span>

![SecondMigration](~/ef6/media/secondmigration.png)

<span data-ttu-id="2fbc8-147">只需按前面所述，当前模型会计算从代码 (1)。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-147">Just like last time, the current model is calculated from code (1).</span></span> <span data-ttu-id="2fbc8-148">但是，这一次有现有迁移以便以前的模型中检索最新的迁移 (2) 中。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-148">However, this time there are existing migrations so the previous model is retrieved from the latest migration (2).</span></span> <span data-ttu-id="2fbc8-149">这两种模型是那样来查找所需的数据库更改 (3)，则该过程完成像以前一样。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-149">These two models are diffed to find the required database changes (3) and then the process completes as before.</span></span>

<span data-ttu-id="2fbc8-150">这一过程用于向项目添加任何进一步迁移。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-150">This same process is used for any further migrations that you add to the project.</span></span>

### <a name="why-bother-with-the-model-snapshot"></a><span data-ttu-id="2fbc8-151">为什么要费力的模型快照？</span><span class="sxs-lookup"><span data-stu-id="2fbc8-151">Why bother with the model snapshot?</span></span>

<span data-ttu-id="2fbc8-152">您可能想知道为什么 EF 麻烦的模型快照-为什么不只是查看数据库。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-152">You may be wondering why EF bothers with the model snapshot – why not just look at the database.</span></span> <span data-ttu-id="2fbc8-153">如果是这样，继续阅读。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-153">If so, read on.</span></span> <span data-ttu-id="2fbc8-154">如果您不感兴趣则可以跳过此部分。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-154">If you’re not interested then you can skip this section.</span></span>

<span data-ttu-id="2fbc8-155">有多种原因而 EF 将周围的模型快照：</span><span class="sxs-lookup"><span data-stu-id="2fbc8-155">There are a number of reasons EF keeps the model snapshot around:</span></span>

-   <span data-ttu-id="2fbc8-156">它允许您以不符合 EF 模型的数据库。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-156">It allows your database to drift from the EF model.</span></span> <span data-ttu-id="2fbc8-157">可以直接在数据库中，进行这些更改也可以更改基架的代码中你迁移，以便进行所做的更改。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-157">These changes can be made directly in the database, or you can change the scaffolded code in your migrations to make the changes.</span></span> <span data-ttu-id="2fbc8-158">下面是几个在实践中的此示例：</span><span class="sxs-lookup"><span data-stu-id="2fbc8-158">Here are a couple of examples of this in practice:</span></span>
    -   <span data-ttu-id="2fbc8-159">你想要添加到一个或多个表的列的插入和更新，但不想要在 EF 模型中包含这些列。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-159">You want to add an Inserted and Updated to column to one or more of your tables but you don’t want to include these columns in the EF model.</span></span> <span data-ttu-id="2fbc8-160">如果迁移介绍了它会不断地尝试删除这些列，每次在已迁移搭建基架的数据库。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-160">If migrations looked at the database it would continually try to drop these columns every time you scaffolded a migration.</span></span> <span data-ttu-id="2fbc8-161">使用的模型快照，EF 只会将检测对模型的合法更改。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-161">Using the model snapshot, EF will only ever detect legitimate changes to the model.</span></span>
    -   <span data-ttu-id="2fbc8-162">你想要更改存储过程用于更新以包括一些日志记录的正文。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-162">You want to change the body of a stored procedure used for updates to include some logging.</span></span> <span data-ttu-id="2fbc8-163">如果迁移介绍了此存储过程从数据库它将不断尝试和其重置回 EF 所需的定义。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-163">If migrations looked at this stored procedure from the database it would continually try and reset it back to the definition that EF expects.</span></span> <span data-ttu-id="2fbc8-164">通过使用模型快照，EF 将只会创建基架的代码来更改存储的过程，当更改形状的 EF 模型中的过程。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-164">By using the model snapshot, EF will only ever scaffold code to alter the stored procedure when you change the shape of the procedure in the EF model.</span></span>
    -   <span data-ttu-id="2fbc8-165">这些原理同样适用于添加额外的索引，在数据库中包括其他表、 将 EF 映射到数据库视图位于通过一个表，等等。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-165">These same principles apply to adding extra indexes, including extra tables in your database, mapping EF to a database view that sits over a table, etc.</span></span>
-   <span data-ttu-id="2fbc8-166">EF 模型包含多个只是数据库的形状。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-166">The EF model contains more than just the shape of the database.</span></span> <span data-ttu-id="2fbc8-167">使整个模型，可以迁移，以便查看有关的属性和您的模型以及它们如何映射到列和表中的类的信息。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-167">Having the entire model allows migrations to look at information about the properties and classes in your model and how they map to the columns and tables.</span></span> <span data-ttu-id="2fbc8-168">此信息使迁移要在代码中，它搭建基架以更智能。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-168">This information allows migrations to be more intelligent in the code that it scaffolds.</span></span> <span data-ttu-id="2fbc8-169">例如，如果您更改某个属性将映射迁移到的列的名称可以检测通过重命名，看看它是同一属性 – 如果你只有数据库架构不能完成的内容。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-169">For example, if you change the name of the column that a property maps to migrations can detect the rename by seeing that it’s the same property – something that can’t be done if you only have the database schema.</span></span> 

## <a name="what-causes-issues-in-team-environments"></a><span data-ttu-id="2fbc8-170">什么会导致在团队环境中的问题</span><span class="sxs-lookup"><span data-stu-id="2fbc8-170">What causes issues in team environments</span></span>

<span data-ttu-id="2fbc8-171">工作流时使用的应用程序上的单个开发人员介绍前面的部分非常好。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-171">The workflow covered in the previous section works great when you are a single developer working on an application.</span></span> <span data-ttu-id="2fbc8-172">它也适用于在团队环境中是唯一的用户对模型进行更改。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-172">It also works well in a team environment if you are the only person making changes to the model.</span></span> <span data-ttu-id="2fbc8-173">在此方案中可以进行模型更改，生成迁移并将其提交到源代码管理。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-173">In this scenario you can make model changes, generate migrations and submit them to your source control.</span></span> <span data-ttu-id="2fbc8-174">其他开发人员可以同步所做的更改并运行**Update-database**使架构更改应用。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-174">Other developers can sync your changes and run **Update-Database** to have the schema changes applied.</span></span>

<span data-ttu-id="2fbc8-175">开始时有多个开发人员对 EF 模型进行更改并提交到源代码管理在同一时间出现问题。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-175">Issues start to arise when you have multiple developers making changes to the EF model and submitting to source control at the same time.</span></span> <span data-ttu-id="2fbc8-176">EF 缺少是一种合并与其他开发人员在自上次同步以来已提交到源代码管理的迁移本地迁移的第一类方法。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-176">What EF lacks is a first class way to merge your local migrations with migrations that another developer has submitted to source control since you last synced.</span></span>

## <a name="an-example-of-a-merge-conflict"></a><span data-ttu-id="2fbc8-177">举例说明了合并冲突</span><span class="sxs-lookup"><span data-stu-id="2fbc8-177">An example of a merge conflict</span></span>

<span data-ttu-id="2fbc8-178">第一个让我们看看一个具体示例的合并冲突。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-178">First let’s look at a concrete example of such a merge conflict.</span></span> <span data-ttu-id="2fbc8-179">我们将继续上与我们在前面的示例。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-179">We’ll continue on with the example we looked at earlier.</span></span> <span data-ttu-id="2fbc8-180">作为起始点让我们假设由原始的开发人员签入上一节中的更改。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-180">As a starting point let’s assume the changes from the previous section were checked in by the original developer.</span></span> <span data-ttu-id="2fbc8-181">当它们更改代码基，我们将跟踪两个开发人员。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-181">We’ll track two developers as they make changes to code base.</span></span>

<span data-ttu-id="2fbc8-182">EF 模型和数更改通过迁移，我们将跟踪。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-182">We’ll track the EF model and the migrations thru a number of changes.</span></span> <span data-ttu-id="2fbc8-183">对于起始点，这两个开发人员已同步到源控件存储库，下, 图中所示。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-183">For a starting point, both developers have synced to the source control repository, as depicted in the following graphic.</span></span>

![StartingPoint](~/ef6/media/startingpoint.png)

<span data-ttu-id="2fbc8-185">开发人员\#1 和开发人员\#2 现在对某些更改其本地代码中的 EF 模型基。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-185">Developer \#1 and developer \#2 now makes some changes to the EF model in their local code base.</span></span> <span data-ttu-id="2fbc8-186">开发人员\#1 添加了**评级**属性设置为**博客**– 并生成**AddRating**迁移，以应用到数据库所做的更改。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-186">Developer \#1 adds a **Rating** property to **Blog** – and generates an **AddRating** migration to apply the changes to the database.</span></span> <span data-ttu-id="2fbc8-187">开发人员\#2 添加**读者**属性设置为**博客**– 并生成相应**AddReaders**迁移。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-187">Developer \#2 adds a **Readers** property to **Blog** – and generates the corresponding **AddReaders** migration.</span></span> <span data-ttu-id="2fbc8-188">这两个开发人员运行**Update-database**，以将所做的更改应用到其本地数据库，然后继续开发应用程序。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-188">Both developers run **Update-Database**, to apply the changes to their local databases, and then continue developing the application.</span></span>

> [!NOTE]
> <span data-ttu-id="2fbc8-189">迁移前面都加有时间戳，因此我们的图形表示从开发人员的 AddReaders 迁移\#2 来自 AddRating 迁移后开发人员\#1。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-189">Migrations are prefixed with a timestamp, so our graphic represents that the AddReaders migration from Developer \#2 comes after the AddRating migration from Developer \#1.</span></span> <span data-ttu-id="2fbc8-190">是否开发人员\#1 或\#2 生成第一个建立的迁移工作在一个团队或合并他们，我们将介绍下一节中的过程中的问题没有影响。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-190">Whether developer \#1 or \#2 generated the migration first makes no difference to the issues of working in a team, or the process for merging them that we’ll look at in the next section.</span></span>

![LocalChanges](~/ef6/media/localchanges.png)

<span data-ttu-id="2fbc8-192">它为开发人员幸运日\#1 发生时将其更改提交第一次。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-192">It’s a lucky day for Developer \#1 as they happen to submit their changes first.</span></span> <span data-ttu-id="2fbc8-193">任何其他人已签入，因为它们同步其存储库，因为它们只是可以无需执行任何合并提交他们的更改。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-193">Because no one else has checked in since they synced their repository, they can just submit their changes without performing any merging.</span></span>

![提交](~/ef6/media/submit.png)

<span data-ttu-id="2fbc8-195">现在，开发人员\#2 提交。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-195">Now it’s time for Developer \#2 to submit.</span></span> <span data-ttu-id="2fbc8-196">他们不是那么幸运。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-196">They aren’t so lucky.</span></span> <span data-ttu-id="2fbc8-197">其他人已提交的更改，因为它们同步，因为它们将需要展开下拉列表的更改和合并。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-197">Because someone else has submitted changes since they synced, they will need to pull down the changes and merge.</span></span> <span data-ttu-id="2fbc8-198">源代码管理系统可能将能够自动合并代码级别的更改，因为它们是非常简单。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-198">The source control system will likely be able to automatically merge the changes at the code level since they are very simple.</span></span> <span data-ttu-id="2fbc8-199">开发人员的状态\#2 的本地存储库后同步在下图中所示。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-199">The state of Developer \#2’s local repository after syncing is depicted in the following graphic.</span></span> 

![请求](~/ef6/media/pull.png)

<span data-ttu-id="2fbc8-201">在此阶段开发人员\#2 可以运行**Update-database**其将检测新**AddRating**迁移 (其中未应用到开发人员\#2 的数据库) 并将其应用。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-201">At this stage Developer \#2 can run **Update-Database** which will detect the new **AddRating** migration (which hasn’t been applied to Developer \#2’s database) and apply it.</span></span> <span data-ttu-id="2fbc8-202">现在**评级**列添加到**博客**该表和数据库是与模型同步。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-202">Now the **Rating** column is added to the **Blogs** table and the database is in sync with the model.</span></span>

<span data-ttu-id="2fbc8-203">但有以下几个问题：</span><span class="sxs-lookup"><span data-stu-id="2fbc8-203">There are a couple of problems though:</span></span>

1.  <span data-ttu-id="2fbc8-204">尽管**Update-database**将应用**AddRating**迁移也将引发警告：*无法更新数据库以匹配当前模型，因为有挂起的更改和禁用自动迁移...*</span><span class="sxs-lookup"><span data-stu-id="2fbc8-204">Although **Update-Database** will apply the **AddRating** migration it will also raise a warning: *Unable to update database to match the current model because there are pending changes and automatic migration is disabled…*</span></span>
    <span data-ttu-id="2fbc8-205">问题是中的最后一个迁移存储的模型快照 (**AddReader**) 缺少**评级**属性上的**博客**(因为它不是模型的一部分时迁移已生成）。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-205">The problem is that the model snapshot stored in the last migration (**AddReader**) is missing the **Rating** property on **Blog** (since it wasn’t part of the model when the migration was generated).</span></span> <span data-ttu-id="2fbc8-206">代码首先检测到的最后一个迁移中的模型不匹配当前模型，并且会引发警告。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-206">Code First detects that the model in the last migration doesn’t match the current model and raises the warning.</span></span>
2.  <span data-ttu-id="2fbc8-207">运行应用程序将导致 InvalidOperationException 消息，指出"*支持 bloggingcontext 上下文的模型创建数据库后已更改。请考虑使用 Code First 迁移更新数据库..."*</span><span class="sxs-lookup"><span data-stu-id="2fbc8-207">Running the application would result in an InvalidOperationException stating that “*The model backing the 'BloggingContext' context has changed since the database was created. Consider using Code First Migrations to update the database…”*</span></span>
    <span data-ttu-id="2fbc8-208">同样，问题是中的最后一个迁移存储的模型快照与当前模型不匹配。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-208">Again, the problem is the model snapshot stored in the last migration doesn’t match the current model.</span></span>
3.  <span data-ttu-id="2fbc8-209">最后，我们期望运行**Add-migration** （因为没有要应用于数据库的更改），现在就会生成空迁移。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-209">Finally, we would expect running **Add-Migration** now would generate an empty migration (since there are no changes to apply to the database).</span></span> <span data-ttu-id="2fbc8-210">但是，由于迁移到的最后一个迁移从一个比较当前模型 (即缺失**评级**属性) 它将实际创建基架另一个**AddColumn** 中添加调用**评级**列。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-210">But because migrations compares the current model to the one from the last migration (which is missing the **Rating** property) it will actually scaffold another **AddColumn** call to add in the **Rating** column.</span></span> <span data-ttu-id="2fbc8-211">当然，此迁移将失败期间**Update-database**因为**评级**列已存在。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-211">Of course, this migration would fail during **Update-Database** because the **Rating** column already exists.</span></span>

## <a name="resolving-the-merge-conflict"></a><span data-ttu-id="2fbc8-212">解决合并冲突</span><span class="sxs-lookup"><span data-stu-id="2fbc8-212">Resolving the merge conflict</span></span>

<span data-ttu-id="2fbc8-213">好消息是，它不太难应对合并手动 – 提供你已迁移的工作原理的了解。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-213">The good news is that it’s not too hard to deal with the merge manually – provided you have an understanding of how migrations works.</span></span> <span data-ttu-id="2fbc8-214">因此，如果您已跳过了此部分...</span><span class="sxs-lookup"><span data-stu-id="2fbc8-214">So if you’ve skipped ahead to this section…</span></span> <span data-ttu-id="2fbc8-215">很抱歉，你需要返回并首先阅读本文的其余部分 ！</span><span class="sxs-lookup"><span data-stu-id="2fbc8-215">sorry, you need to go back and read the rest of the article first!</span></span>

<span data-ttu-id="2fbc8-216">有两个选项，最简单的方法是生成具有正确的当前模型为以快照形式的空白迁移。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-216">There are two options, the easiest is to generate a blank migration that has the correct current model as a snapshot.</span></span> <span data-ttu-id="2fbc8-217">第二个选项是更新的快照中的最后一个迁移以具有正确的模型快照。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-217">The second option is to update the snapshot in the last migration to have the correct model snapshot.</span></span> <span data-ttu-id="2fbc8-218">第二个选项是有点困难，不能使用在每个方案中，但它也是更简洁因为它不涉及添加额外的迁移。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-218">The second option is a little harder and can’t be used in every scenario, but it’s also cleaner because it doesn’t involve adding an extra migration.</span></span>

### <a name="option-1-add-a-blank-merge-migration"></a><span data-ttu-id="2fbc8-219">选项 1： 添加空白合并的迁移</span><span class="sxs-lookup"><span data-stu-id="2fbc8-219">Option 1: Add a blank ‘merge’ migration</span></span>

<span data-ttu-id="2fbc8-220">在此选项中我们生成空白迁移专门用于确保最新的迁移都是正确的模型快照存储在其中。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-220">In this option we generate a blank migration solely for the purpose of making sure the latest migration has the correct model snapshot stored in it.</span></span>

<span data-ttu-id="2fbc8-221">此选项可以使用而不考虑用户生成的最后一个迁移。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-221">This option can be used regardless of who generated the last migration.</span></span> <span data-ttu-id="2fbc8-222">在示例中我们已遵循开发人员\#2 会负责合并和生成的最后一个迁移发生。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-222">In the example we’ve been following Developer \#2 is taking care of the merge and they happened to generate the last migration.</span></span> <span data-ttu-id="2fbc8-223">但可以使用这些相同的步骤，如果开发人员\#1 生成的最后一个迁移。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-223">But these same steps can be used if Developer \#1 generated the last migration.</span></span> <span data-ttu-id="2fbc8-224">如果有多个迁移涉及 – 我们只介绍了在两个以使其保持简单，步骤也适用。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-224">The steps also apply if there are multiple migrations involved – we’ve just been looking at two in order to keep it simple.</span></span>

<span data-ttu-id="2fbc8-225">以下过程可以用于这种方法，从您意识到需要进行更改，需要从源代码管理同步的时间开始。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-225">The following process can be used for this approach, starting from the time you realize you have changes that need to be synced from source control.</span></span>

1.  <span data-ttu-id="2fbc8-226">请确保您的本地代码库中的任何挂起的模型更改已写入迁移。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-226">Ensure any pending model changes in your local code base have been written to a migration.</span></span> <span data-ttu-id="2fbc8-227">此步骤可确保生成空白迁移时，不要错过合法的任何更改。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-227">This step ensures you don’t miss any legitimate changes when it comes time to generate the blank migration.</span></span>
2.  <span data-ttu-id="2fbc8-228">与源代码管理同步。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-228">Sync with source control.</span></span>
3.  <span data-ttu-id="2fbc8-229">运行**Update-database**来应用其他开发人员在签入任何新迁移。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-229">Run **Update-Database** to apply any new migrations that other developers have checked in.</span></span>
    <span data-ttu-id="2fbc8-230">\*\*
    *注意: \* \* \* 如果不更新数据库命令中获取所有警告并没有任何其他开发人员的新迁移和无需执行任何合并。*</span><span class="sxs-lookup"><span data-stu-id="2fbc8-230">**
*Note:****if you don’t get any warnings from the Update-Database command then there were no new migrations from other developers and there is no need to perform any further merging.*</span></span>
4.  <span data-ttu-id="2fbc8-231">运行**Add-migration&lt;选取\_\_名称&gt;– IgnoreChanges** (例如， **Add-migration 合并 – IgnoreChanges**)。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-231">Run **Add-Migration &lt;pick\_a\_name&gt; –IgnoreChanges** (for example, **Add-Migration Merge –IgnoreChanges**).</span></span> <span data-ttu-id="2fbc8-232">这与 （包括当前模型的快照） 的所有元数据生成迁移，但将忽略比较当前模型到最后一个迁移中的快照时检测到的任何更改 (这意味着获取空白**向上**和**向下**方法)。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-232">This generates a migration with all the metadata (including a snapshot of the current model) but will ignore any changes it detects when comparing the current model to the snapshot in the last migrations (meaning you get a blank **Up** and **Down** method).</span></span>
5.  <span data-ttu-id="2fbc8-233">在继续开发，或者 （后运行单元测试当然） 提交到源代码管理。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-233">Continue developing, or submit to source control (after running your unit tests of course).</span></span>

<span data-ttu-id="2fbc8-234">下面是开发人员的状态\#2 的本地代码库后使用此方法。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-234">Here is the state of Developer \#2’s local code base after using this approach.</span></span>

![MergeMigration](~/ef6/media/mergemigration.png)

### <a name="option-2-update-the-model-snapshot-in-the-last-migration"></a><span data-ttu-id="2fbc8-236">选项 2： 更新中的最后一个迁移的模型快照</span><span class="sxs-lookup"><span data-stu-id="2fbc8-236">Option 2: Update the model snapshot in the last migration</span></span>

<span data-ttu-id="2fbc8-237">此选项与选项 1 非常相似，但可消除额外的空白迁移 –，因为我们面对现实吧，希望在其解决方案中的额外的代码文件。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-237">This option is very similar to option 1 but removes the extra blank migration – because let’s face it, who wants extra code files in their solution.</span></span>

<span data-ttu-id="2fbc8-238">**如果最新迁移仅在您的本地代码库中存在，并且有尚未提交到源代码管理 （例如，如果由用户执行合并生成的最后一个迁移），这种方法才可行**。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-238">**This approach is only feasible if the latest migration exists only in your local code base and has not yet been submitted to source control (for example, if the last migration was generated by the user doing the merge)**.</span></span> <span data-ttu-id="2fbc8-239">编辑元数据的迁移的其他开发人员可能已应用到其开发数据库 – 甚至更糟糕的是应用于生产数据库可能会导致意外的副作用。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-239">Editing the metadata of migrations that other developers may have already applied to their development database – or even worse applied to a production database – can result in unexpected side effects.</span></span> <span data-ttu-id="2fbc8-240">在过程中我们将回滚我们本地数据库中的最后一个迁移并重新将其应用与更新的元数据。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-240">During the process we’re going to roll back the last migration in our local database and re-apply it with updated metadata.</span></span>

<span data-ttu-id="2fbc8-241">而最后一个迁移需要只是为本地代码库的数量或顺序继续其迁移到没有限制。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-241">While the last migration needs to just be in the local code base there are no restrictions to the number or order of migrations that proceed it.</span></span> <span data-ttu-id="2fbc8-242">可以有多个不同的开发人员从多个迁移和步骤同样适用 – 我们只介绍了在两个以使其保持简单。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-242">There can be multiple migrations from multiple different developers and the same steps apply– we’ve just been looking at two in order to keep it simple.</span></span>

<span data-ttu-id="2fbc8-243">以下过程可以用于这种方法，从您意识到需要进行更改，需要从源代码管理同步的时间开始。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-243">The following process can be used for this approach, starting from the time you realize you have changes that need to be synced from source control.</span></span>

1.  <span data-ttu-id="2fbc8-244">请确保您的本地代码库中的任何挂起的模型更改已写入迁移。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-244">Ensure any pending model changes in your local code base have been written to a migration.</span></span> <span data-ttu-id="2fbc8-245">此步骤可确保生成空白迁移时，不要错过合法的任何更改。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-245">This step ensures you don’t miss any legitimate changes when it comes time to generate the blank migration.</span></span>
2.  <span data-ttu-id="2fbc8-246">与源代码管理同步。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-246">Sync with the source control.</span></span>
3.  <span data-ttu-id="2fbc8-247">运行**Update-database**来应用其他开发人员在签入任何新迁移。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-247">Run **Update-Database** to apply any new migrations that other developers have checked in.</span></span>
    <span data-ttu-id="2fbc8-248">\*\*
    *注意: \* \* \* 如果不更新数据库命令中获取所有警告并没有任何其他开发人员的新迁移和无需执行任何合并。*</span><span class="sxs-lookup"><span data-stu-id="2fbc8-248">**
*Note:****if you don’t get any warnings from the Update-Database command then there were no new migrations from other developers and there is no need to perform any further merging.*</span></span>
4.  <span data-ttu-id="2fbc8-249">运行**更新数据库 – TargetMigration&lt;第二个\_上次\_迁移&gt;** (这是在示例中我们已一直关注**更新数据库 –TargetMigration AddRating**)。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-249">Run **Update-Database –TargetMigration &lt;second\_last\_migration&gt;** (in the example we’ve been following this would be **Update-Database –TargetMigration AddRating**).</span></span> <span data-ttu-id="2fbc8-250">此角色在数据库返回的第二个状态上次迁移 – 有效地未应用从数据库的最后一个迁移。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-250">This roles the database back to the state of the second last migration – effectively ‘un-applying’ the last migration from the database.</span></span>
    <span data-ttu-id="2fbc8-251">\*\*
    *注意: \* \* \* 此步骤中需要它以便安全地编辑元数据的迁移，因为元数据也存储在\_ \_MigrationsHistoryTable 的数据库。这就是原因仅在你本地代码库中的最后一个迁移时，应仅使用此选项。如果其他数据库的应用的最后一个迁移将具有它们回滚并重新应用更新元数据的最后一个迁移。*</span><span class="sxs-lookup"><span data-stu-id="2fbc8-251">**
*Note:****This step is required to make it safe to edit the metadata of the migration since the metadata is also stored in the \_\_MigrationsHistoryTable of the database. This is why you should only use this option if the last migration is only in your local code base. If other databases had the last migration applied you would also have to roll them back and re-apply the last migration to update the metadata.*</span></span> 
5.  <span data-ttu-id="2fbc8-252">运行**Add-migration&lt;完整\_名称\_包括\_时间戳\_的\_最后一个\_迁移**&gt; （在本例中我们已一直关注这将是类似**Add-migration 201311062215252\_AddReaders**)。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-252">Run **Add-Migration &lt;full\_name\_including\_timestamp\_of\_last\_migration**&gt; (in the example we’ve been following this would be something like **Add-Migration 201311062215252\_AddReaders**).</span></span>
    <span data-ttu-id="2fbc8-253">\*\*
    *注意: \* \* \* 需要包含时间戳，以便让迁移知道你想要编辑现有的迁移，而不是一个新的基架。*</span><span class="sxs-lookup"><span data-stu-id="2fbc8-253">**
    *Note:****You need to include the timestamp so that migrations knows you want to edit the existing migration rather than scaffolding a new one.*</span></span>
<span data-ttu-id="2fbc8-254">这会更新以匹配当前模型的最后一个迁移的元数据。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-254">This will update the metadata for the last migration to match the current model.</span></span> <span data-ttu-id="2fbc8-255">该命令完成，但这正是你想时，你将收到以下警告。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-255">You’ll get the following warning when the command completes, but that’s exactly what you want.</span></span> <span data-ttu-id="2fbc8-256">"*设计器代码仅迁移"201311062215252\_AddReaders' 已重新已搭建基架。若要重新创建整个迁移基架，请使用-Force 参数。"*</span><span class="sxs-lookup"><span data-stu-id="2fbc8-256">“*Only the Designer Code for migration '201311062215252\_AddReaders' was re-scaffolded. To re-scaffold the entire migration, use the -Force parameter.”*</span></span>
6.  <span data-ttu-id="2fbc8-257">运行**Update-database**重新应用迁移的最新过程中更新的元数据。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-257">Run **Update-Database** to re-apply the latest migration with the updated metadata.</span></span>
7.  <span data-ttu-id="2fbc8-258">在继续开发，或者 （后运行单元测试当然） 提交到源代码管理。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-258">Continue developing, or submit to source control (after running your unit tests of course).</span></span>

<span data-ttu-id="2fbc8-259">下面是开发人员的状态\#2 的本地代码库后使用此方法。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-259">Here is the state of Developer \#2’s local code base after using this approach.</span></span>

![UpdatedMetadata](~/ef6/media/updatedmetadata.png)

## <a name="summary"></a><span data-ttu-id="2fbc8-261">总结</span><span class="sxs-lookup"><span data-stu-id="2fbc8-261">Summary</span></span>

<span data-ttu-id="2fbc8-262">在团队环境中使用 Code First 迁移时，有一些难题。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-262">There are some challenges when using Code First Migrations in a team environment.</span></span> <span data-ttu-id="2fbc8-263">但是，基本了解迁移的工作原理和解决合并冲突一些简单的方法轻松地解决这些难题。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-263">However, a basic understanding of how migrations works and some simple approaches for resolving merge conflicts make it easy to overcome these challenges.</span></span>

<span data-ttu-id="2fbc8-264">基本问题是不正确的元数据存储在最新的迁移。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-264">The fundamental issue is incorrect metadata stored in the latest migration.</span></span> <span data-ttu-id="2fbc8-265">这将导致代码第一个错误地检测不匹配当前模型和数据库架构和搭建基架，在下一步的迁移中的代码不正确。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-265">This causes Code First to incorrectly detect that the current model and database schema don’t match and to scaffold incorrect code in the next migration.</span></span> <span data-ttu-id="2fbc8-266">可以通过生成具有正确的模型，空白迁移或更新最新的迁移中的元数据来克服这种情况。</span><span class="sxs-lookup"><span data-stu-id="2fbc8-266">This situation can be overcome by generating a blank migration with the correct model, or updating the metadata in the latest migration.</span></span>
